[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Software Engineering at Google",
    "section": "",
    "text": "Software Engineering at Google\n\nPreface: Software Engineering Over Time\n\n\nSummary\nIn the ever-changing industry, the term “programming” is no longer being refered solely as technical term, but rather the process from start to finish regarding this act of “writing code”: building and maintaining the code over time.\nKey insight: Software Engineering can been thought of as “programming integrated over time”\nThere are 03 questions and priciples software engineers should keep in mind:\n\nTime and Change: How code will need to adapt over the length of its life\nScale and Growth: How an organization will need to adapt as it evolves\nTrade-offs and Costs: How an organization makes decisions, based on the lessons of Time and Change and Scale and Growth\n\nThroughout this book, we will learn each of this principle in-depth.\n\n\nAction Items\nHow topics covered in the reading can be implemented to the Chasten project\n\nWe should plan ahead the approach to write our program in a timely manner: well-planned schedule, detailed scope of work, class and team goals\nStrategies to keep track with changes: Because we have a large team of software engineers, there will be time of unexpected change. As we operate on a blame-free environment, we should work on the problem by assigning a group of people to work on fixing the problem in a timely manner.\nTrade-offs and Costs: We should decide which feature to build, keeping in mind the opportunity cost, technical cost, people cost. etc.\n\n\nWhat is Software Engineering? Beyond just Programming\n\n\n\nSummary\nAt its core, programming is about writing code-creating the algorthms and logic that make a software program work. On the other hand, softare engineering goes beyond coding, it covers the full life cycle of a software system, from idea to production and maintenance.\n\n\nThree Critical Factors\n\nTime Dimension: Engineers must not only create code but also maintain it over time. Therefore, the role of a software engineer extend the role of a programmer, looking beyond the immediate problems and solutions.\nScale and Growth: Software Engineering acknowledges the vast scales of modern applications and technology. The growth and scalability of software systems are integral considerations that go beyond the scope of only programming.\nTrade-offs: Engineers must weigh various factors and costs, such as financial, resource, engineering effort, and make informed decisions.\n\n\n\nImplications for Individual Software Engineers\nWe should recognize that software engineering entails more than just writing code and solving immediate problems. It involves the ongoing commitment to maintain, improve, and adapt the code over its lifespan. * Be ready to adapt: Being a software engineer means being prepared to respond to changes in product requirments and technology. * Responsibility for Maintenance: Beyond initial program development, engineers should anticipate and embrace their role in maintaining code. They should actively look for problems in the program way before the maintainance phase to save time and cost in the future * Hyrum’s Law: Be aware of unintended consequences of changes\n\n\nImplications for Chasten\nWhile Chasten may not be as extensive as some industrial system, it still benefits from these core principles: * Time & Change: Consider its potential for extended use within the Department of Computer and Information Science, software engineers should anticipate future maintenance and evolution needs. * Trade-offs: Balancing the deesire for features and complexity with the need for maintainability and time constraint is key, especially with Chasten, which will be implemented in approximately five weeks. * Scalability: There are endless possibilities of how Chasten would be used and scaled. What if other departments or universities express interest? Designing the code and processes with scalability in mind can help you in the long run.\n\n\nAction Items\n\nDocumentation of code and issue\nTesting and Quality Assurance\nVersion Control\nMaintain open channels of communication within the team\nModular Design Practices to make it easier to modify the program without disrupting the entire system.\n\n\n\n\nThe Fuzzing Book\n\nIntroduction to Software Testing\n\nIn the fast-paced world of software development, ensuring the functionality of your programs is immensely important. In this chapter, we’ll delve into the fundamentals of software testing.\n\nWhat does Software Testing Mean?\nSotware Testing is the process of evaluating a program to identify defects and issues. The purposes of software testing are: * Identifying and fixing bugs early in the process * Ensuring that the software meets the specified requirements, behaves as expected * Reducing the risk of software failures in deployment.\n\n\nTesting Strategies\n\nUtilizing ‘print()’ Statement: One of the most straightforward yet effective debugging techniques is the ‘print’ statements. This technique involves strategically printing relevant information that provides information into whether the program is running correctly.\nAutomatic Test Execution and ‘assert()’ Statement: By crafting comprehensive test suites with assert statements, you can systematically check if your code behaves correcly.\nRounding Error: Introducing Epsilon: Some programs make exact comparisons challengeing by having float type. To tackle this issue, the concept of “epsilon” is employed, determining whether two floating-point values are considered equal. Developers often check if the absolute difference between the values of floating-point numbers is less than or equal to epsilon.\nGenerating Tests: Apply Your Test to Thousands of Inputs: To increase confidence in your software’s correctness (and also reduce the time and effort spend testing each input), consider generating tests with a wide range of inputs.\nIntegrating Checks: For robust and reliable code, consider integrating checks directly into your functions. You can utilize Assertions to ensure that the inputs and outputs conform to expected behavior.\n\n\n\nApplications on Chasten\nIt’s a collaborative effort to ensure the software run correctly. After reading this chapter, here are some action items I suggest implementing: 1. Avoid overconfidence in your code and acknowledge that things can go wrong. 2. Rigorous Testing: To ensure the highest quality of your code, run as many tests as possible. 3. Collaborate and Seek Insights: Consult with Software Quality Assurance engineer and colleagues with diverse and creative perspectives.\n\nCode Coverage\n\nCode coverage is a vital aspect of software testing to provide valuable insights into the effectiveness of test cases and testing efforts.\n\n\nSummary of Code Coverage\nCode coverage is a metric used in software testing to measure the extend to which a program’s source code is executed by a set of test cases. By tracking which lines of code, branches, and conditions have been executed, it quatifies the coverage of the codebase.\n\n\nList of Testing Approaches\n\nCoverage Class\nThe Coverage class allows you to measure and report code coverage using a variety of its method. + trace() Method: sets up code tracing by reporting data during test execution. + coverage() Method: reports coverage results, indicating which parts of your code were covered.\n\n\nTesting Approaches\n\nBlack Box Testing: This approach focuses on evaluating the functionality of software application without knowledge of its internal code and structure. Testers design test cases based on specification and requirements. The primary goal of black box testing is to ensure that the software meets its intended functionality.\nWhite Box Testing: In contrast, white-box testing involves the knowledge of internal code structure and logic. The goal of this approach is to ensure code correctness, coverage and issues related to code structure.\nTracing Execution using sys.settrace(): This function allows you to set a trace of function that performs automatically to give inforamtion about certain aspect. Common parameters are “frame”,“event”, and “argument”\nFuzzing Test: a testing technique that involves generating a range of random input (could be customized to be mixed character and integer) to uncover defects.\n\n\n\nReflection\nAs a beginner in programming, I often found myself excited about solcing coding challenges and building software solutions. The satisfation to see my code work sometimes led me to being overconfident in the correctness of my work. After all, if the program executed without immediate errors, it must be fine, right? However, from time to time, I have been proven wrong as I began working on more complex projects. I started to realize that there was more to ensuring the quality and reliability of my code than just making it run. I discovered that power of “nothing as such as being too careful” with program execution and the invaluable role of code coverage. The logic I applied to solve immediate coding problems was crucial, but it was only part of the software development process. The early detection of issues helps me ensure the quality of the program."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Jaclyn Pham",
    "section": "",
    "text": "My name is Jaclyn Pham and welcome to my blog! What I am currently doing:\n\nCurrently a junior double majoring in Software Engineering and Art, Science & Innovation\nI am a technical leader in the Department of Computer and Information Science\nI also take the role as a workshop leader in the ALIC Workshop Seties, a program I initiated within the Art Department\nLead Designer at SheCodes Hackathon Vietnam 2023\nI have experience in digital art and programming. I developed projects that blend the realms of art and technology."
  }
]