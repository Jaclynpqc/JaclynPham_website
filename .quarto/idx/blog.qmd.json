{"title":"Software Engineering at Google","markdown":{"headingText":"Software Engineering at Google","containsRefs":false,"markdown":"\n\n<h2 style=\"color:orange\"> Software Engineering @ Google 1: Software Engineering Over Time </h2>\n\n##### Summary\n\nIn the ever-changing industry, the term \"programming\" is no longer being refered solely as technical term, but rather the process from start to finish regarding this act of \"writing code\": building and maintaining the code over time. \n\n***Key insight***: Software Engineering can been thought of as \"programming integrated over time\"\n\n\nThere are ***03 questions and priciples*** software engineers should keep in mind:\n\n* Time and Change: How code will need to adapt over the length of its life\n* Scale and Growth: How an organization will need to adapt as it evolves\n* Trade-offs and Costs: How an organization makes decisions, based on the lessons of Time and Change and Scale and Growth\n\nThroughout this book, we will learn each of this principle in-depth. \n\n##### Action Items\n***How topics covered in the reading can be implemented to the Chasten project***\n\n* We should plan ahead the approach to write our program in a timely manner: well-planned schedule, detailed scope of work, class and team goals\n* Strategies to keep track with changes: Because we have a large team of software engineers, there will be time of unexpected change. As we operate on a blame-free environment, we should work on the problem by assigning a group of people to work on fixing the problem in a timely manner. \n* Trade-offs and Costs: We should decide which feature to build, keeping in mind the opportunity cost, technical cost, people cost. etc. \n\n<h2 style=\"color:orange\"> Software Engineering @ Google 2: What is Software Engineering? Beyond just Programming </h2>\n\n##### Summary\n\nAt its core, programming is about writing code-creating the algorthms and logic that make a software program work. On the other hand, softare engineering goes beyond coding, it covers the full life cycle of a software system, from idea to production and maintenance. \n\n##### Three Critical Factors\n* Time Dimension: Engineers must not only create code but also maintain it over time. Therefore, the role of a software engineer extend the role of a programmer, looking beyond the immediate problems and solutions.\n* Scale and Growth: Software Engineering acknowledges the vast scales of modern applications and technology. The growth and scalability of software systems are integral considerations that go beyond the scope of only programming. \n* Trade-offs: Engineers must weigh various factors and costs, such as financial, resource, engineering effort, and make informed decisions. \n\n##### Implications for Individual Software Engineers\nWe should recognize that software engineering entails more than just writing code and solving immediate problems. It involves the ongoing commitment to maintain, improve, and adapt the code over its lifespan.\n* Be ready to adapt: Being a software engineer means being prepared to respond to changes in product requirments and technology. \n* Responsibility for Maintenance: Beyond initial program development, engineers should anticipate and embrace their role in maintaining code. They should actively look for problems in the program way before the maintainance phase to save time and cost in the future\n* Hyrum's Law: Be aware of unintended consequences of changes\n\n##### Implications for Chasten\nWhile Chasten may not be as extensive as some industrial system, it still benefits from these core principles:\n* Time & Change: Consider its potential for extended use within the Department of Computer and Information Science, software engineers should anticipate future maintenance and evolution needs.\n* Trade-offs: Balancing the deesire for features and complexity with the need for maintainability and time constraint is key, especially with Chasten, which will be implemented in approximately five weeks. \n* Scalability: There are endless possibilities of how Chasten would be used and scaled. What if other departments or universities express interest? Designing the code and processes with scalability in mind can help you in the long run.\n\n##### Action Items\n* Documentation of code and issue\n* Testing and Quality Assurance\n* Version Control\n* Maintain open channels of communication within the team\n* Modular Design Practices to make it easier to modify the program without disrupting the entire system.\n\n<h2 style=\"color:orange\"> Software Engineering @ Google 3: Software Engineering is a team endeavor! </h2>\n\n##### Summary\n\nThis chapter delves into the infrastructure of a software engineering team. It underscores the pivotal role of teamwork in achieving remarkable results and emphasizes the significance of self-awareness within the team. \n\n##### The Trade-Offs of Working Alone\n\nOne of the challenges in software development is the temptation to work alone, sheltering codes and ideas until they're perceived as perfect. However, this solitary approach has some trade-offs:\n* Longer Struggles\n* Delayed Error Detection\n\n##### The Collaborative Nirvana\nDealing with social problems can be challenging and unpredictable.To unlock the full potential of teamwork, this chapter introduces three pillars of social interaction:\n* Humility: Embracing the fact that everyone has room for improvement paves the way for collective growth. **Failure is an option**\n* Respect: Acknowledges the value of each team member and encourages open dialogue and diverse perspectives\n* Trust: The belief that others are competent and will do the right thing\n\n##### Action Items\n* Regular Team Meetings and Check-Ins\n* Peer Mentoring and Knowledge Sharing\n* Acknowledge the strength of each team member, celebrate success and learn from failures\n\n<h2 style=\"color:orange\"> Software Engineering @ Google 4: Knowledge Sharing </h2>\n\n##### Summary\n\nThe chapter \"Knowledge Sharing\" from the book \"Software Engineering at Google\" illuminates the vital aspects of effective team communication and knowledge distribution within a software engienering environment. Central to the chapter is teh creation of a supportive work atmosphere where team members feel comfortable expressing ideas. making mistakes, and learnign collaboratively. It emphasizes the importance of dismantling infomration, addressing data fragmentation, and combating the fear of \"haunted graveyard\" code. The chapter stresses the significance of uniform knowledge distribution to prevent inconsistencies within the team, thus enhancing efficiency and preventing setbakcs caused by the sudden unavailability of key individuals.\n\n##### Reflection\n\nThis chapter's highlights problem also relate to our challenge with team-work in Chaste. A significant challenge we face is the struggle to share vital information, and each software engineer lack connection with each other. This chapter's teaching us in real-world context, emphasizes the urgency of finding creative and proactive solutions to enhance out communication and collaboration.\n\n##### Action Items\n* Form Collaborative Teams: Our strength is communicating in small teams, hence we should form focused team and work collaboratively to solve each individual issues.\n* Establishing a centralized knowledge repository\n* Continuous Feedback Loops\n\n<h2 style=\"color:orange\"> Software Engineering @ Google 5: Engineering for Equity </h2>\n\n##### Summary\n\nThe chapter \"Engineering for Equity\" from the book \"Software Engineering at Google\" sheds light on the pervasive issues of unconscious bias in engineering. These biases often lead to the creation of products that cater to a specific group, leaving out diverse perspectives and needs. One striking example discussed is the development of tools ar AI training models that disadvantage people of color. The chapter emphasizes the importance of understanding how products can either advantage or disadvantage certain groups, highlightling the need for a comprehensive approach to tackle these multifaceted challenges.\n\nThe chapter suggests several strategies to address these biases effectively. Here are some suggestions: \n* Improve engineers knowledge of diversity\n* Making them aware of the biases \n* Understanding the diverse needs of users\n* Rejecting singular approaches\n* Ensuring diverse representation at the management level. \n\n##### Reflection\n\nIn previous chapter, we explored the multifaceted role of a software engineer- as an individual, as a team player, as a learner. However, in this chaper, the spotlight shifts to the engineers as a catalyst for change in promoting diversity and inclusivity. The chapter encapsulates this role with a statement: \"When engineering does not focus on users of different nationalities, ethnicities, races, genders, ages, socioeconomic statuses, abilities, and belief systems, even the most talented staff will inadvertently fail their users.\". This statement underscore the essence of the software engineer's responsibility to craft products that resonate with the diverse tapestry of humanity. \n\nThis realization ties back to the core purpose of software engineering -to create impactful and useful product that enhance people's lives. It highlights that the essence of technology progress lies not only in innovation but also in empathy, understanding, and inclusion.\n\n##### Action Items for Chasten\nUser Research: Comprehensively research users from diverse backgrounds will help us understand their unique needs, challenges, and expectations to inform the product development process\n\n\n# The Fuzzing Book \n\n<h2 style=\"color:purple\"> Fuzzing Book 1: Introduction to Software Testing </h2>\n\nIn the fast-paced world of software development, ensuring the functionality of your programs is immensely important. In this chapter, we'll delve into the fundamentals of software testing.\n\n##### What does Software Testing Mean?\n\nSoftware Testing is the process of evaluating a program to identify defects and issues. The purposes of software testing are:\n* Identifying and fixing bugs early in the process\n* Ensuring that the software meets the specified requirements, behaves as expected\n* Reducing the risk of software failures in deployment.\n\n##### Testing Strategies\n\n* **Utilizing 'print()' Statement:** One of the most straightforward yet effective debugging techniques is the 'print' statements. This technique involves strategically printing relevant information that provides information into whether the program is running correctly. \n* **Automatic Test Execution and 'assert()' Statement:** By crafting comprehensive test suites with assert statements, you can systematically check if your code behaves correcly.\n* **Rounding Error: Introducing Epsilon:** Some programs make exact comparisons challengeing by having float type. To tackle this issue, the concept of \"epsilon\" is employed, determining whether two floating-point values are considered equal. Developers often check if the absolute difference between the values of floating-point numbers is less than or equal to epsilon. \n* **Generating Tests: Apply Your Test to Thousands of Inputs:** To increase confidence in your software's correctness (and also reduce the time and effort spend testing each input), consider generating tests with a wide range of inputs. \n* **Integrating Checks:** For robust and reliable code, consider integrating checks directly into your functions. You can utilize Assertions to ensure that the inputs and outputs conform to expected behavior.\n\n##### Applications on Chasten\n\nIt's a collaborative effort to ensure the software run correctly. After reading this chapter, here are some action items I suggest implementing:\n1. Avoid overconfidence in your code and acknowledge that things can go wrong.\n2. Rigorous Testing: To ensure the highest quality of your code, run as many tests as possible. \n3. Collaborate and Seek Insights: Consult with Software Quality Assurance engineer and colleagues with diverse and creative perspectives. \n\n<h2 style=\"color:purple\"> Fuzzing Book 2: Code Coverage  </h2>\n\nCode coverage is a vital aspect of software testing to provide valuable insights into the effectiveness of test cases and testing efforts. \n\n##### Summary of Code Coverage\n**Code coverage** is a metric used in software testing to measure the extend to which a program's source code is executed by a set of test cases. By tracking which lines of code, branches, and conditions have been executed, it quatifies the coverage of the codebase. \n\n##### List of Testing Approaches\n\n###### Coverage Class\nThe Coverage class allows you to measure and report code coverage using a variety of its method.\n+ trace() Method: sets up code tracing by reporting data during test execution. \n+ coverage() Method: reports coverage results, indicating which parts of your code were covered. \n\n\n###### Testing Approaches\n+ Black Box Testing: This approach focuses on evaluating the functionality of software application without knowledge of its internal code and structure. Testers design test cases based on specification and requirements. The primary goal of black box testing is to ensure that the software meets its intended functionality. \n+ White Box Testing: In contrast, white-box testing involves the knowledge of internal code structure and logic. The goal of this approach is to ensure code correctness, coverage and issues related to code structure.\n+ Tracing Execution using sys.settrace(): This function allows you to set a trace of function that performs automatically to give inforamtion about certain aspect. Common parameters are \"frame\",\"event\", and \"argument\"\n+ Fuzzing Test: a testing technique that involves generating a range of random input (could be customized to be mixed character and integer) to uncover defects. \n\n###### Reflection\nAs a beginner in programming, I often found myself excited about solcing coding challenges and building software solutions. The satisfation to see my code work sometimes led me to being overconfident in the correctness of my work. After all, if the program executed without immediate errors, it must be fine, right?\nHowever, from time to time, I have been proven wrong as I began working on more complex projects. I started to realize that there was more to ensuring the quality and reliability of my code than just making it run. I discovered that power of \"nothing as such as being too careful\" with program execution and the invaluable role of code coverage. The logic I applied to solve immediate coding problems was crucial, but it was only part of the software development process. The early detection of issues helps me ensure the quality of the program.\n\n\n<h2 style=\"color:purple\"> Fuzzing Book 3: Breaking Things in Random Input </h2>\n\nFuzzing is a testing technique that involves generating a range of random input to uncover defects.\n\n\n###### Benefits of Fuzzing\nThe fuzzing code generates a diverse range of inputs and delivers them relectlessly to the target application. The goal is to stress-test the software and identify any unexpected vulnerabilities.\nFuzz testing has been identifying various issues, including buffer overflows, crashes, and security vulnerabilities. \n\n###### Fuzzer and Runner\n\nFuzzer() is responsible for delivering the diverse set of inputs to the target application. The Fuzzer can be modified to generate only number or characters.\n\n```\nimport random\ndef fuzzer(max_length: int=100, char_start: int = 32, char_range: int = 32) -> str:\n    \"\"\"A string of up to `max_length` characters in the range ['char_start','char_start'+ 'char_range']\"\"\"\n    string_length = random.randrange(0, max_length + 1)\n    out = \"\"\n    for i in range(0,string_length):\n        out += char(random.randrange(char_start,char_start+char_range))\n    return out\n```\n\nRunner() is the component responsible for executing the target application with teh generated input. It captures the program's behavisor, logs any crashes and indentifies potential vulnerabilities.\n\n###### Fuzzing External Programs\nSetting up fuzz testing for external programs allows for a comprehensive assessment of interconnected systems. This ensures that the program is thouroughly and rigorously tested, helping you uncover vulnerabilities that might go unnoticed.\n\n<h2 style=\"color:purple\"> Fuzzing Book 4: Mutation Analysis </h2>\n\nMutation analysis is a sophisticate technique, which injects artificial faults into the code and scrutinizes how test suites responds. Utilizing mutation analysis, developers gain invaluable insights into the efficacy of their tests. This blog post navigates the intricate world of mutation anlysis, revealing its principles, challenges, and real-world applications.\n\n###### Benefits of Mutation Analysis\n**Test Suit Effectiveness Assessment**\nMutation analysis evaluates the quality of the test suite by introducing artificial faults into the code. It helps developers understand how well your tests can detect these injected errors, providing insights into the thoroughness of your testing efforts\nMutation analysis can be used as an indicator of test suit effectiveness. The more mutants killed by tests, the better the test suite.\n**Identifying Weaknesses**\nBy pinpointing specific areas where your tests fail to catch mutations, mutation analysis highlights weaknesses in your code. This information is invaluable for strengthening your test cases and improving overall code quality. \n\n###### Real-World Application on Chasten Program\nIn our Chasten project, mutation analysis could be applied by purposely injecting false XPath pattern to test the analyze feature's ability to detect the bugs. \n\n<h2 style=\"color:purple\"> Fuzzing Book 5: Mutation-Based Fuzzing </h2>\nMutation-based fuzzing is a software tesing technique used to discover vulnerabilities or bugs in programs, especially in softwrae that parses complex inputs. Fuzzing involves feedding a program with a large amount of randomly generated or mutated data to trigger unexpected behavior. \n\n###### The process of mutation-based fuzzing\n1. **Input Generation** - Fuzzer general initial inputs either randomly or from existing valid inputs. These inputs can be in various formats.\n2. **Mutation** - Fuzzer mutates mutates the generated inputs to create new,slightly modified inputs. The idea is to explore different way the program approach the bugs to uncover potential vulnerabilities.\n3. **Input Execution** -The mutated inputs are fed into the target program. The program's behavior is monitored and analyzed.\n4. **Error Detection** -If the program exibits abnormal behavior, the fuzzer detects these errors and logs the input that caused the issue\n\n###### Application on Chasten\nMutation-based fuzzing can be applied to test a software tool that checks XPath expressions, like Chasten, by generating a variety of mutated XPath expressions and feeding them into the tool to uncover potential vulnerabilities.\nThe mutated inputs can start with a set of valid XPath expressions taht the software tool should accept, and then be mutated through different ways, such as delete random character, insert random characters or flip random characters. ","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"blog.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}